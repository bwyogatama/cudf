# Copyright (c) 2022-2023, NVIDIA CORPORATION.
import glob
import os

from cubinlinker.patch import _numba_version_ok, get_logger, new_patched_linker
from cuda import cudart
from numba import cuda
from numba.cuda.cudadrv.driver import Linker
from ptxcompiler.patch import NO_DRIVER, safe_get_versions

from cudf.core.udf.utils import _get_ptx_file

from . import _version

__version__ = _version.get_versions()["version"]

logger = get_logger()


def _get_cuda_version_from_ptx_file(path):
    """
    https://docs.nvidia.com/cuda/parallel-thread-execution/
    Each PTX module must begin with a .version
    directive specifying the PTX language version

    example header:
    //
    // Generated by NVIDIA NVVM Compiler
    //
    // Compiler Build ID: CL-31057947
    // Cuda compilation tools, release 11.6, V11.6.124
    // Based on NVVM 7.0.1
    //

    .version 7.6
    .target sm_52
    .address_size 64

    """
    with open(path) as ptx_file:
        for line in ptx_file:
            if line.startswith(".version"):
                ver_line = line
                break
        else:
            raise ValueError("Could not read CUDA version from ptx file.")
    version = ver_line.strip("\n").split(" ")[1]
    # from ptx_docs/release_notes above:
    ver_map = {
        "7.5": (11, 5),
        "7.6": (11, 6),
        "7.7": (11, 7),
        "7.8": (11, 8),
        "8.0": (12, 0),
    }

    cuda_ver = ver_map.get(version)
    if cuda_ver is None:
        raise ValueError(
            f"Could not map PTX version {version} to a CUDA version"
        )

    return cuda_ver


path = os.path.dirname(__file__)


def maybe_patch_numba_linker(driver_version, ptx_toolkit_version):
    print(f"driver version is {driver_version}")
    print(f"ptx toolkit version is {ptx_toolkit_version}")
    # Numba thinks cubinlinker is only needed if the driver is older than the ctk
    # but when strings_udf is present, it might also need to patch because the PTX
    # file strings_udf relies on may be newer than the driver as well
    if driver_version < ptx_toolkit_version:
        print(
            "Driver version %s.%s needs patching due to strings_udf"
            % driver_version
        )
        if _numba_version_ok:
            logger.debug("Patching Numba Linker")
            Linker.new = new_patched_linker
        else:
            logger.debug("Cannot patch Numba Linker - unsupported version")
    else:
        print("not patching numba linker")


# Maximum size of a string column is 2 GiB
_STRINGS_UDF_DEFAULT_HEAP_SIZE = os.environ.get(
    "STRINGS_UDF_HEAP_SIZE", 2**31
)
heap_size = 0


def set_malloc_heap_size(size=None):
    """
    Heap size control for strings_udf, size in bytes.
    """
    global heap_size
    if size is None:
        size = _STRINGS_UDF_DEFAULT_HEAP_SIZE
    if size != heap_size:
        (ret,) = cudart.cudaDeviceSetLimit(
            cudart.cudaLimit.cudaLimitMallocHeapSize, size
        )
        if ret.value != 0:
            raise RuntimeError("Unable to set cudaMalloc heap size")

        heap_size = size


ptxpath = None
versions = safe_get_versions()
if versions != NO_DRIVER:
    driver_version, runtime_version = versions
    ptxpath = _get_ptx_file(path, "shim_")
    strings_udf_ptx_version = _get_cuda_version_from_ptx_file(ptxpath)
    maybe_patch_numba_linker(driver_version, strings_udf_ptx_version)
